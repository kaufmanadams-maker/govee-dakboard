<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Govee Lights – DakBoard</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      color-scheme: dark;
      --bg: #050816;
      --panel: #111827;
      --panel-alt: #0b1220;
      --accent: #2563eb;
      --accent-soft: rgba(37, 99, 235, 0.15);
      --text-main: #e5e7eb;
      --text-muted: #9ca3af;
      --error: #f97373;
      --border-subtle: #1f2937;
      --radius-lg: 18px;
      --radius-pill: 999px;
    }

    * {
      box-sizing: border-box;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text",
        "Segoe UI", sans-serif;
    }

    body {
      margin: 0;
      padding: 16px;
      background: radial-gradient(circle at top, #111827 0, #020617 55%);
      color: var(--text-main);
    }

    .card {
      max-width: 480px;
      margin: 0 auto;
      padding: 18px 18px 14px;
      background: linear-gradient(135deg, #020617, #020617 40%, #111827);
      border-radius: 24px;
      box-shadow:
        0 26px 60px rgba(15, 23, 42, 0.95),
        0 0 0 1px rgba(148, 163, 184, 0.08);
      border: 1px solid rgba(148, 163, 184, 0.18);
      position: relative;
      overflow: hidden;
    }

    .card::before {
      content: "";
      position: absolute;
      inset: -40%;
      opacity: 0.16;
      background:
        radial-gradient(circle at 0 0, rgba(59, 130, 246, 0.65), transparent 55%),
        radial-gradient(circle at 100% 0, rgba(236, 72, 153, 0.7), transparent 55%),
        radial-gradient(circle at 0 100%, rgba(45, 212, 191, 0.6), transparent 55%);
      pointer-events: none;
      mix-blend-mode: screen;
    }

    .card-inner {
      position: relative;
      z-index: 1;
    }

    h1 {
      font-size: 1.05rem;
      letter-spacing: 0.09em;
      text-transform: uppercase;
      color: #e5e7eb;
      margin: 0 0 4px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .badge-api {
      margin-left: auto;
      font-size: 0.62rem;
      text-transform: uppercase;
      letter-spacing: 0.14em;
      color: var(--text-muted);
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.35);
      background-color: rgba(15, 23, 42, 0.72);
      backdrop-filter: blur(6px);
      white-space: nowrap;
    }

    .subtitle {
      margin: 0 0 12px;
      font-size: 0.75rem;
      color: var(--text-muted);
    }

    .header-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      margin-bottom: 8px;
    }

    #statusText {
      font-size: 0.7rem;
      color: var(--text-muted);
      padding: 4px 8px;
      border-radius: 999px;
      background-color: rgba(15, 23, 42, 0.88);
      border: 1px solid rgba(55, 65, 81, 0.9);
      white-space: nowrap;
      max-width: 100%;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .pill {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.4);
      background-color: rgba(15, 23, 42, 0.8);
      font-size: 0.7rem;
      color: var(--text-muted);
      margin-bottom: 2px;
    }

    .section {
      margin-top: 8px;
      padding: 10px 10px 9px;
      border-radius: var(--radius-lg);
      background: radial-gradient(circle at top left, rgba(15, 23, 42, 0.98), #020617);
      border: 1px solid rgba(31, 41, 55, 0.85);
    }

    .section-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 4px;
      margin-bottom: 6px;
    }

    .section-title {
      font-size: 0.72rem;
      letter-spacing: 0.16em;
      text-transform: uppercase;
      color: #9ca3af;
    }

    .section-hint {
      font-size: 0.66rem;
      color: var(--text-muted);
    }

    label {
      font-size: 0.7rem;
      color: var(--text-muted);
      display: block;
      margin-bottom: 4px;
    }

    input[type="password"],
    select {
      width: 100%;
      padding: 6px 9px;
      border-radius: 10px;
      border: 1px solid rgba(55, 65, 81, 0.9);
      background-color: rgba(15, 23, 42, 0.96);
      color: var(--text-main);
      font-size: 0.78rem;
      outline: none;
    }

    input[type="password"]:focus,
    select:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 1px rgba(37, 99, 235, 0.7);
    }

    .btn-row {
      display: flex;
      gap: 6px;
      margin-top: 6px;
      flex-wrap: wrap;
    }

    button {
      border: none;
      border-radius: var(--radius-pill);
      padding: 6px 12px;
      font-size: 0.72rem;
      font-weight: 500;
      cursor: pointer;
      background: rgba(15, 23, 42, 0.98);
      color: var(--text-main);
      border: 1px solid rgba(55, 65, 81, 0.95);
      transition:
        background 120ms ease-out,
        transform 80ms ease-out,
        box-shadow 120ms ease-out,
        border-color 120ms ease-out;
      white-space: nowrap;
    }

    button.primary {
      background: radial-gradient(circle at top left, #3b82f6, #1d4ed8);
      border-color: rgba(96, 165, 250, 0.95);
      box-shadow:
        0 0 0 1px rgba(59, 130, 246, 0.55),
        0 14px 30px rgba(37, 99, 235, 0.6);
    }

    button.primary:hover {
      filter: brightness(1.06);
      transform: translateY(-0.5px);
    }

    button.secondary {
      background: rgba(15, 23, 42, 0.96);
    }

    button.secondary:hover {
      background: rgba(30, 64, 175, 0.45);
      border-color: rgba(96, 165, 250, 0.7);
    }

    button.danger {
      background: rgba(127, 29, 29, 0.9);
      border-color: rgba(248, 113, 113, 0.9);
      color: #fee2e2;
    }

    button.danger:hover {
      background: rgba(185, 28, 28, 0.96);
    }

    button:active {
      transform: translateY(0.4px) scale(0.99);
      box-shadow: none;
    }

    button:disabled {
      opacity: 0.45;
      cursor: default;
      box-shadow: none;
      transform: none;
    }

    .controls-grid {
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 6px;
      margin-top: 4px;
      margin-bottom: 4px;
    }

    .controls-grid button {
      text-align: center;
      padding-inline: 0;
    }

    .slider-row {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-top: 6px;
    }

    input[type="range"] {
      flex: 1;
      accent-color: #60a5fa;
    }

    .slider-label {
      font-size: 0.7rem;
      color: var(--text-muted);
      width: 60px;
      text-align: left;
    }

    .slider-value {
      font-size: 0.7rem;
      color: var(--text-muted);
      width: 40px;
      text-align: right;
    }

    .color-row {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-top: 6px;
    }

    input[type="color"] {
      width: 38px;
      height: 22px;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.8);
      padding: 0;
      background: transparent;
      cursor: pointer;
    }

    .footer {
      margin-top: 8px;
      font-size: 0.65rem;
      color: var(--text-muted);
      display: flex;
      justify-content: space-between;
      gap: 8px;
      opacity: 0.8;
    }

    .footer span {
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      max-width: 70%;
    }
  </style>
</head>
<body>
  <div class="card">
    <div class="card-inner">
      <div class="header-row">
        <div>
          <h1>Govee Lights</h1>
          <p class="subtitle">Cloud API · DakBoard widget</p>
        </div>
        <div class="badge-api">Cloud API · v1</div>
      </div>

      <!-- Configuration -->
      <div class="section">
        <div class="section-header">
          <div class="section-title">Configuration</div>
          <div class="pill">Stored in browser</div>
        </div>
        <label for="apiKeyInput">Govee API Key</label>
        <input id="apiKeyInput" type="password" autocomplete="off" />
        <div class="btn-row">
          <button id="saveKeyBtn" class="primary">Save</button>
          <button id="loadDevicesBtn" class="secondary">Reload devices</button>
          <button id="clearConfigBtn" class="danger">Clear config</button>
        </div>
      </div>

      <!-- Target selection -->
      <div class="section">
        <div class="section-header">
          <div class="section-title">Target</div>
          <div class="section-hint">Groups + individual lights</div>
        </div>
        <label for="targetSelect">Device or group</label>
        <select id="targetSelect">
          <option value="">No devices loaded</option>
        </select>
      </div>

      <!-- Controls -->
      <div class="section">
        <div class="section-header">
          <div class="section-title">Controls</div>
          <div class="section-hint">Power · Brightness · Color · Scene</div>
        </div>

        <div class="controls-grid">
          <button id="onBtn" class="primary">On</button>
          <button id="offBtn" class="secondary">Off</button>
          <button id="refreshBtn" class="secondary">Refresh</button>
        </div>

        <div class="slider-row">
          <div class="slider-label">Brightness</div>
          <input id="brightnessRange" type="range" min="1" max="100" value="100" />
          <span class="slider-value" id="brightnessValue">100%</span>
        </div>
        <div class="btn-row">
          <button id="setBrightnessBtn" class="secondary" style="flex: 1;">
            Set brightness
          </button>
        </div>

        <div class="color-row">
          <div class="slider-label">Color</div>
          <input id="colorPicker" type="color" value="#ffffff" />
          <button id="setColorBtn" class="secondary" style="flex: 1;">
            Set color
          </button>
        </div>

        <div style="margin-top: 8px;">
          <label for="sceneSelect">Dynamic scene (API)</label>
          <select id="sceneSelect">
            <option value="">No scenes loaded</option>
          </select>
          <div class="btn-row">
            <button id="loadScenesBtn" class="secondary" style="flex: 1;">
              Load scenes
            </button>
            <button id="applySceneBtn" class="secondary" style="flex: 1;">
              Apply scene
            </button>
          </div>
        </div>
      </div>

      <div class="footer">
        <span id="statusText">Idle.</span>
        <span>OpenAPI v1</span>
      </div>
    </div>
  </div>

  <script>
    const BASE_URL = "https://openapi.api.govee.com";
    const DEVICES_URL = BASE_URL + "/router/api/v1/user/devices";
    const CONTROL_URL = BASE_URL + "/router/api/v1/device/control";
    const STATE_URL = BASE_URL + "/router/api/v1/device/state";
    const SCENES_URL = BASE_URL + "/router/api/v1/device/scenes";

    const apiKeyInput = document.getElementById("apiKeyInput");
    const saveKeyBtn = document.getElementById("saveKeyBtn");
    const clearConfigBtn = document.getElementById("clearConfigBtn");
    const loadDevicesBtn = document.getElementById("loadDevicesBtn");

    const targetSelect = document.getElementById("targetSelect");

    const onBtn = document.getElementById("onBtn");
    const offBtn = document.getElementById("offBtn");
    const refreshBtn = document.getElementById("refreshBtn");

    const brightnessRange = document.getElementById("brightnessRange");
    const brightnessValue = document.getElementById("brightnessValue");
    const setBrightnessBtn = document.getElementById("setBrightnessBtn");

    const colorPicker = document.getElementById("colorPicker");
    const setColorBtn = document.getElementById("setColorBtn");

    const sceneSelect = document.getElementById("sceneSelect");
    const loadScenesBtn = document.getElementById("loadScenesBtn");
    const applySceneBtn = document.getElementById("applySceneBtn");

    const statusText = document.getElementById("statusText");

    // Cache of device capabilities keyed by "device|sku"
    const DEVICE_CAPS_INDEX = new Map();

    function setStatus(message, isError) {
      statusText.textContent = message;
      if (isError) {
        statusText.style.color = "#f97373";
        statusText.style.borderColor = "rgba(248,113,113,0.9)";
      } else {
        statusText.style.color = "#9ca3af";
        statusText.style.borderColor = "rgba(55,65,81,0.9)";
      }
    }

    function getApiKey() {
      return apiKeyInput.value.trim();
    }

    function uuidFallback() {
      if (window.crypto && window.crypto.randomUUID) {
        return window.crypto.randomUUID();
      }
      return String(Date.now()) + "-" + Math.floor(Math.random() * 1e9);
    }

    function saveApiKeyToStorage() {
      try {
        const key = getApiKey();
        if (key) {
          localStorage.setItem("goveeApiKey", key);
          setStatus("API key saved. Loading devices…", false);
          loadDevices();
        } else {
          setStatus("Enter an API key before saving.", true);
        }
      } catch (e) {
        setStatus("Cannot save API key: " + e.message, true);
      }
    }

    function loadApiKeyFromStorage() {
      try {
        const key = localStorage.getItem("goveeApiKey");
        if (key) {
          apiKeyInput.value = key;
          setStatus("API key loaded. Loading devices…", false);
          loadDevices();
        }
      } catch {
        /* ignore */
      }
    }

    function clearConfig() {
      try {
        localStorage.removeItem("goveeApiKey");
      } catch {
        /* ignore */
      }
      apiKeyInput.value = "";
      targetSelect.innerHTML =
        '<option value="">No devices loaded</option>';
      DEVICE_CAPS_INDEX.clear();
      sceneSelect.innerHTML =
        '<option value="">No scenes loaded</option>';
      setStatus("Config cleared.", false);
      updateTargetUi(null);
    }

    function classifyDevice(device) {
      const caps = device.capabilities || [];
      const key = device.device + "|" + device.sku;
      const supports = {
        hasPower: false,
        hasBrightness: false,
        hasColor: false,
        hasScenes: false
      };

      caps.forEach((c) => {
        if (
          c.type === "devices.capabilities.on_off" &&
          c.instance === "powerSwitch"
        ) {
          supports.hasPower = true;
        }
        if (
          c.type === "devices.capabilities.range" &&
          c.instance === "brightness"
        ) {
          supports.hasBrightness = true;
        }
        if (
          c.type === "devices.capabilities.color_setting" &&
          c.instance === "colorRgb"
        ) {
          supports.hasColor = true;
        }
        if (c.type === "devices.capabilities.dynamic_scene") {
          supports.hasScenes = true;
        }
      });

      DEVICE_CAPS_INDEX.set(key, supports);

      // Heuristic: groups are SameModeGroup or things that only expose on/off
      const isGroup =
        device.sku === "SameModeGroup" ||
        (!supports.hasBrightness &&
          !supports.hasColor &&
          !supports.hasScenes &&
          supports.hasPower);

      return { key, supports, isGroup };
    }

    function populateTargetSelect(devices) {
      targetSelect.innerHTML = "";

      const placeholder = document.createElement("option");
      placeholder.value = "";
      placeholder.textContent = "Select device or group…";
      targetSelect.appendChild(placeholder);

      const lights = [];
      const groups = [];

      devices.forEach((d) => {
        const info = classifyDevice(d);
        const base = {
          device: d.device,
          sku: d.sku,
          name: d.deviceName || d.device || d.sku || "Unnamed",
          isGroup: info.isGroup
        };
        if (info.isGroup) {
          groups.push(base);
        } else {
          lights.push(base);
        }
      });

      if (groups.length) {
        const og = document.createElement("optgroup");
        og.label = "Groups";
        groups.forEach((g) => {
          const opt = document.createElement("option");
          opt.value = JSON.stringify({
            device: g.device,
            sku: g.sku,
            kind: "group"
          });
          opt.textContent = "⬗ " + g.name;
          og.appendChild(opt);
        });
        targetSelect.appendChild(og);
      }

      if (lights.length) {
        const og = document.createElement("optgroup");
        og.label = "Lights";
        lights.forEach((l) => {
          const opt = document.createElement("option");
          opt.value = JSON.stringify({
            device: l.device,
            sku: l.sku,
            kind: "light"
          });
          opt.textContent = "◦ " + l.name;
          og.appendChild(opt);
        });
        targetSelect.appendChild(og);
      }

      if (!groups.length && !lights.length) {
        targetSelect.innerHTML =
          '<option value="">No devices returned</option>';
      }
    }

    async function loadDevices() {
      const apiKey = getApiKey();
      if (!apiKey) {
        setStatus("Enter your Govee API key first.", true);
        return;
      }

      setStatus("Loading devices…", false);
      targetSelect.innerHTML =
        '<option value="">Loading…</option>';
      DEVICE_CAPS_INDEX.clear();

      try {
        const res = await fetch(DEVICES_URL, {
          method: "GET",
          headers: {
            "Govee-API-Key": apiKey
          }
        });

        if (!res.ok) {
          const text = await res.text();
          throw new Error("HTTP " + res.status + " " + text);
        }

        const data = await res.json();
        if (data.code !== 200) {
          throw new Error(
            "API error code " + data.code + ": " + (data.msg || data.message || "unknown")
          );
        }

        const devices = Array.isArray(data.data) ? data.data : [];
        if (!devices.length) {
          targetSelect.innerHTML =
            '<option value="">No devices found.</option>';
          setStatus("No devices returned from API.", true);
          return;
        }

        populateTargetSelect(devices);
        setStatus("Devices loaded (" + devices.length + ").", false);
        updateTargetUi(null);
      } catch (e) {
        console.error(e);
        targetSelect.innerHTML =
          '<option value="">Error loading devices</option>';
        setStatus("Device load failed: " + e.message, true);
        DEVICE_CAPS_INDEX.clear();
        updateTargetUi(null);
      }
    }

    function getSelectedTarget() {
      const value = targetSelect.value;
      if (!value) return null;
      try {
        const parsed = JSON.parse(value);
        if (!parsed || !parsed.device || !parsed.sku) return null;
        return parsed;
      } catch {
        return null;
      }
    }

    function updateTargetUi(target) {
      let supports = null;
      if (target && target.device && target.sku) {
        const key = target.device + "|" + target.sku;
        supports = DEVICE_CAPS_INDEX.get(key) || null;
      }

      const hasBrightness = supports && supports.hasBrightness;
      const hasColor = supports && supports.hasColor;
      const hasScenes = supports && supports.hasScenes;

      brightnessRange.disabled = !hasBrightness;
      setBrightnessBtn.disabled = !hasBrightness;
      brightnessValue.style.opacity = hasBrightness ? "1" : "0.4";

      colorPicker.disabled = !hasColor;
      setColorBtn.disabled = !hasColor;

      sceneSelect.disabled = !hasScenes;
      loadScenesBtn.disabled = !hasScenes;
      applySceneBtn.disabled = !hasScenes;

      if (!target) {
        setStatus("Select a device or group.", false);
        return;
      }

      if (target.kind === "group") {
        if (!supports) {
          setStatus("Group selected. On/Off likely supported.", false);
        } else if (!hasBrightness && !hasColor && !hasScenes) {
          setStatus("Group selected. API exposes On/Off only.", false);
        } else {
          setStatus("Group selected.", false);
        }
      } else {
        setStatus("Device selected.", false);
      }
    }

    async function sendControl(capability) {
      const apiKey = getApiKey();
      if (!apiKey) {
        setStatus("Enter your Govee API key first.", true);
        return;
      }

      const sel = getSelectedTarget();
      if (!sel) {
        setStatus("Select a device or group first.", true);
        return;
      }

      setStatus("Sending command…", false);

      try {
        const res = await fetch(CONTROL_URL, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "Govee-API-Key": apiKey
          },
          body: JSON.stringify({
            requestId: uuidFallback(),
            payload: {
              device: sel.device,
              sku: sel.sku,
              capability
            }
          })
        });

        if (!res.ok) {
          const text = await res.text();
          throw new Error("HTTP " + res.status + " " + text);
        }

        const data = await res.json();
        if (data.code !== 200) {
          throw new Error(
            "API error code " + data.code + ": " + (data.msg || data.message || "unknown")
          );
        }

        setStatus("Command sent successfully.", false);
      } catch (e) {
        console.error(e);
        setStatus("Command failed: " + e.message, true);
      }
    }

    async function refreshState() {
      const apiKey = getApiKey();
      if (!apiKey) {
        setStatus("Enter your Govee API key first.", true);
        return;
      }

      const sel = getSelectedTarget();
      if (!sel) {
        setStatus("Select a device or group first.", true);
        return;
      }

      setStatus("Refreshing state…", false);

      try {
        const res = await fetch(STATE_URL, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "Govee-API-Key": apiKey
          },
          body: JSON.stringify({
            requestId: uuidFallback(),
            payload: {
              device: sel.device,
              sku: sel.sku
            }
          })
        });

        if (!res.ok) {
          const text = await res.text();
          throw new Error("HTTP " + res.status + " " + text);
        }

        const data = await res.json();
        if (data.code !== 200) {
          throw new Error(
            "API error code " + data.code + ": " + (data.msg || data.message || "unknown")
          );
        }

        const caps = (data.payload && data.payload.capabilities) || [];

        const brightCap = caps.find(
          (c) =>
            c.type === "devices.capabilities.range" &&
            c.instance === "brightness" &&
            c.state &&
            typeof c.state.value === "number"
        );
        if (brightCap) {
          const v = Math.max(1, Math.min(100, Math.round(brightCap.state.value)));
          brightnessRange.value = String(v);
          brightnessValue.textContent = v + "%";
        }

        const colorCap = caps.find(
          (c) =>
            c.type === "devices.capabilities.color_setting" &&
            c.instance === "colorRgb" &&
            c.state &&
            typeof c.state.value === "number"
        );
        if (colorCap) {
          const rgbInt = colorCap.state.value;
          const r = (rgbInt >> 16) & 255;
          const g = (rgbInt >> 8) & 255;
          const b = rgbInt & 255;
          const hex =
            "#" +
            [r, g, b]
              .map((x) => x.toString(16).padStart(2, "0"))
              .join("");
          colorPicker.value = hex;
        }

        setStatus("State refreshed.", false);
      } catch (e) {
        console.error(e);
        setStatus("State refresh failed: " + e.message, true);
      }
    }

    async function loadScenes() {
      const apiKey = getApiKey();
      if (!apiKey) {
        setStatus("Enter your Govee API key first.", true);
        return;
      }

      const sel = getSelectedTarget();
      if (!sel) {
        setStatus("Select a device first.", true);
        return;
      }

      const caps = DEVICE_CAPS_INDEX.get(sel.device + "|" + sel.sku);
      if (!caps || !caps.hasScenes) {
        setStatus("Selected target does not expose scenes via API.", true);
        return;
      }

      setStatus("Loading scenes…", false);
      sceneSelect.innerHTML =
        '<option value="">Loading…</option>';

      try {
        const res = await fetch(SCENES_URL, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "Govee-API-Key": apiKey
          },
          body: JSON.stringify({
            requestId: uuidFallback(),
            payload: {
              device: sel.device,
              sku: sel.sku
            }
          })
        });

        if (!res.ok) {
          const text = await res.text();
          throw new Error("HTTP " + res.status + " " + text);
        }

        const data = await res.json();
        if (data.code !== 200) {
          throw new Error(
            "API error code " + data.code + ": " + (data.msg || data.message || "unknown")
          );
        }

        const payload = data.payload || {};
        const capsArr = payload.capabilities || [];
        const dynCap = capsArr.find(
          (c) => c.type === "devices.capabilities.dynamic_scene"
        );

        const options =
          dynCap &&
          dynCap.parameters &&
          Array.isArray(dynCap.parameters.options)
            ? dynCap.parameters.options
            : [];

        if (!options.length) {
          sceneSelect.innerHTML =
            '<option value="">No scenes available</option>';
          setStatus("No dynamic scenes reported for this device.", false);
          return;
        }

        sceneSelect.innerHTML = "";
        options.forEach((opt) => {
          const o = document.createElement("option");
          o.value = JSON.stringify({
            instance: dynCap.instance,
            value: opt.value
          });
          o.textContent = opt.name || "Scene " + String(opt.value);
          sceneSelect.appendChild(o);
        });

        setStatus("Scenes loaded.", false);
      } catch (e) {
        console.error(e);
        sceneSelect.innerHTML =
          '<option value="">Error loading scenes</option>';
        setStatus("Scene load failed: " + e.message, true);
      }
    }

    function applyScene() {
      const raw = sceneSelect.value;
      if (!raw) {
        setStatus("Select a scene first.", true);
        return;
      }
      let conf;
      try {
        conf = JSON.parse(raw);
      } catch {
        setStatus("Invalid scene selection.", true);
        return;
      }
      sendControl({
        type: "devices.capabilities.dynamic_scene",
        instance: conf.instance,
        value: conf.value
      });
    }

    // Event wiring
    brightnessRange.addEventListener("input", () => {
      brightnessValue.textContent = brightnessRange.value + "%";
    });

    saveKeyBtn.addEventListener("click", saveApiKeyToStorage);
    clearConfigBtn.addEventListener("click", clearConfig);
    loadDevicesBtn.addEventListener("click", loadDevices);

    targetSelect.addEventListener("change", () => {
      const sel = getSelectedTarget();
      updateTargetUi(sel);
      // Clear scenes list when switching targets
      sceneSelect.innerHTML =
        '<option value="">No scenes loaded</option>';
    });

    onBtn.addEventListener("click", () =>
      sendControl({
        type: "devices.capabilities.on_off",
        instance: "powerSwitch",
        value: 1
      })
    );

    offBtn.addEventListener("click", () =>
      sendControl({
        type: "devices.capabilities.on_off",
        instance: "powerSwitch",
        value: 0
      })
    );

    setBrightnessBtn.addEventListener("click", () => {
      const val = Math.max(
        1,
        Math.min(100, parseInt(brightnessRange.value, 10) || 1)
      );
      sendControl({
        type: "devices.capabilities.range",
        instance: "brightness",
        value: val
      });
    });

    setColorBtn.addEventListener("click", () => {
      const hex = colorPicker.value || "#ffffff";
      const r = parseInt(hex.slice(1, 3), 16);
      const g = parseInt(hex.slice(3, 5), 16);
      const b = parseInt(hex.slice(5, 7), 16);
      const rgbInt = (r << 16) + (g << 8) + b;
      sendControl({
        type: "devices.capabilities.color_setting",
        instance: "colorRgb",
        value: rgbInt
      });
    });

    refreshBtn.addEventListener("click", refreshState);
    loadScenesBtn.addEventListener("click", loadScenes);
    applySceneBtn.addEventListener("click", applyScene);

    // Init
    loadApiKeyFromStorage();
    updateTargetUi(null);
  </script>
</body>
</html>
